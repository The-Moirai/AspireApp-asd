# 缓存优化使用指南

## 概述

基于Redis诊断测试的成功结果（所有测试通过，平均响应时间1-3ms），我们已经实现了优化的分层缓存系统。本指南将帮助您充分利用缓存性能，提升应用响应速度。

## 测试结果分析

### ✅ 测试通过情况
- **基础连接测试**: 连接成功，响应时间3.89ms
- **配置检查**: 连接字符串正确，ConnectionMultiplexer已连接
- **网络连接测试**: 网络连接正常，Redis响应时间1.54ms
- **权限测试**: 读写删除权限正常
- **性能测试**: 性能测试完成，总时间29ms，平均2ms/次，操作数10
- **健康检查**: Redis服务健康，PING响应时间1.32ms

### 📊 性能指标
- 平均响应时间: 1-3ms
- 性能测试成功率: 100%
- 连接稳定性: 优秀
- 网络延迟: 极低

## 缓存架构

### 分层缓存策略
```
┌─────────────────┐
│   内存缓存      │ ← 最快访问 (1-2ms)
│  (L1 Cache)     │
└─────────────────┘
         │
         ▼
┌─────────────────┐
│   Redis缓存     │ ← 持久化存储 (1-3ms)
│  (L2 Cache)     │
└─────────────────┘
         │
         ▼
┌─────────────────┐
│   数据库        │ ← 数据源 (10-100ms)
│  (Data Source)  │
└─────────────────┘
```

### 缓存优先级
- **Critical**: 实时数据，1分钟内存缓存
- **High**: 高频访问数据，2分钟内存缓存
- **Medium**: 常规数据，5分钟内存缓存
- **Low**: 历史数据，10分钟内存缓存

## 使用指南

### 1. 基本缓存操作

#### 获取缓存
```csharp
// 使用优化的缓存服务
var drone = await _optimizedCacheService.GetAsync<Drone>("drone:123", CachePriority.High);
```

#### 设置缓存
```csharp
// 设置缓存，指定优先级
await _optimizedCacheService.SetAsync("drone:123", drone, TimeSpan.FromMinutes(30), CachePriority.High);
```

#### 获取或设置缓存
```csharp
// 缓存预热模式
var drones = await _optimizedCacheService.GetOrSetAsync("drones:all", 
    async () => await _droneRepository.GetAllAsync(), 
    TimeSpan.FromMinutes(15), 
    CachePriority.Medium);
```

### 2. 批量操作

#### 批量获取
```csharp
var keys = new[] { "drone:1", "drone:2", "drone:3" };
var drones = await _optimizedCacheService.GetMultipleAsync<Drone>(keys, CachePriority.High);
```

#### 批量设置
```csharp
var droneDict = drones.ToDictionary(d => $"drone:{d.Id}", d => d);
await _optimizedCacheService.SetMultipleAsync(droneDict, TimeSpan.FromMinutes(30), CachePriority.High);
```

### 3. 缓存管理

#### 检查缓存存在性
```csharp
var exists = await _optimizedCacheService.ExistsAsync("drone:123");
```

#### 移除缓存
```csharp
await _optimizedCacheService.RemoveAsync("drone:123");
```

#### 刷新缓存
```csharp
await _optimizedCacheService.RefreshAsync("drone:123");
```

## 最佳实践

### 1. 缓存键命名规范
```
// 推荐格式: {业务模块}:{数据类型}:{标识符}
"drones:all"                    // 所有无人机
"drone:123:status"              // 无人机状态
"tasks:active"                  // 活跃任务
"task:456:subtasks"             // 任务子项
"images:task:789:recent"        // 最近图片
```

### 2. 优先级选择策略
```csharp
// 实时数据 - Critical优先级
await _optimizedCacheService.SetAsync($"drone:{droneId}:realtime", data, null, CachePriority.Critical);

// 高频访问数据 - High优先级
await _optimizedCacheService.SetAsync("drones:all", drones, TimeSpan.FromMinutes(15), CachePriority.High);

// 常规数据 - Medium优先级
await _optimizedCacheService.SetAsync($"task:{taskId}", task, TimeSpan.FromMinutes(30), CachePriority.Medium);

// 历史数据 - Low优先级
await _optimizedCacheService.SetAsync($"history:{date}", historyData, TimeSpan.FromHours(2), CachePriority.Low);
```

### 3. 缓存预热策略
```csharp
// 应用启动时预热关键数据
public async Task WarmupCacheAsync()
{
    // 预热所有无人机数据
    await _optimizedCacheService.GetOrSetAsync("drones:all", 
        async () => await _droneRepository.GetAllAsync(), 
        TimeSpan.FromMinutes(15), 
        CachePriority.High);

    // 预热活跃任务
    await _optimizedCacheService.GetOrSetAsync("tasks:active", 
        async () => await _taskRepository.GetActiveTasksAsync(), 
        TimeSpan.FromMinutes(10), 
        CachePriority.High);
}
```

### 4. 缓存失效策略
```csharp
// 数据更新时清除相关缓存
public async Task UpdateDroneAsync(Drone drone)
{
    // 更新数据库
    await _droneRepository.UpdateAsync(drone);
    
    // 清除相关缓存
    await _optimizedCacheService.RemoveAsync($"drone:{drone.Id}");
    await _optimizedCacheService.RemoveAsync($"drone:{drone.Id}:status");
    await _optimizedCacheService.RemoveAsync("drones:all");
}
```

## 监控和管理

### 1. 缓存统计API
```http
GET /api/cachemanagement/statistics
```

返回详细的缓存统计信息：
- 内存缓存命中率
- Redis缓存命中率
- 总体命中率
- 缓存未命中率

### 2. 性能报告API
```http
GET /api/cachemanagement/performance-report
```

提供性能分析和优化建议。

### 3. 缓存管理API
```http
# 检查缓存项
GET /api/cachemanagement/exists/{key}

# 移除缓存项
DELETE /api/cachemanagement/remove/{key}

# 刷新缓存项
POST /api/cachemanagement/refresh/{key}

# 清除所有缓存
POST /api/cachemanagement/clear-all

# 批量移除
POST /api/cachemanagement/batch-remove
Body: ["key1", "key2", "key3"]
```

## 性能优化建议

### 1. 基于测试结果的优化
- **利用低延迟优势**: Redis响应时间仅1-3ms，可以频繁访问
- **内存缓存优先**: 对于高频数据，优先使用内存缓存
- **批量操作**: 使用批量API减少网络往返

### 2. 缓存策略调整
```csharp
// 实时数据 - 更短的过期时间
await _optimizedCacheService.SetAsync(key, value, TimeSpan.FromSeconds(30), CachePriority.Critical);

// 静态数据 - 更长的过期时间
await _optimizedCacheService.SetAsync(key, value, TimeSpan.FromHours(1), CachePriority.Low);
```

### 3. 错误处理和降级
```csharp
try
{
    var data = await _optimizedCacheService.GetAsync<T>(key);
    return data;
}
catch (Exception ex)
{
    _logger.LogWarning(ex, "缓存访问失败，降级到数据库");
    return await _repository.GetAsync(id);
}
```

## 配置说明

### appsettings.json 配置
```json
{
  "Cache": {
    "Redis": {
      "InstanceName": "AspireApp_",
      "DefaultExpirationMinutes": 30,
      "ShortTermExpirationMinutes": 5,
      "LongTermExpirationMinutes": 120,
      "EnableCompression": true,
      "EnableSerializationOptimization": true
    },
    "Memory": {
      "SizeLimit": 1000,
      "CompactionPercentage": 0.1,
      "ExpirationScanFrequency": "00:05:00"
    },
    "Strategy": {
      "EnableTieredCaching": true,
      "EnableCacheWarming": true,
      "EnableCacheInvalidation": true,
      "EnableCacheStatistics": true,
      "RealTimeDataPriority": "High",
      "HistoricalDataPriority": "Medium"
    }
  }
}
```

## 故障排除

### 1. 常见问题
- **缓存未命中率高**: 检查缓存键策略和过期时间
- **内存使用过高**: 调整内存缓存大小限制
- **Redis连接失败**: 使用诊断API检查连接状态

### 2. 诊断工具
```http
# Redis连接诊断
POST /api/redisdiagnostic/diagnose

# 缓存性能测试
POST /api/cachemanagement/performance-test?iterations=100
```

## 总结

基于Redis测试的优秀结果，我们的缓存系统具有以下优势：

1. **极低延迟**: 1-3ms响应时间
2. **高可靠性**: 100%测试通过率
3. **分层架构**: 内存+Redis双重缓存
4. **智能管理**: 自动统计和优化建议
5. **灵活配置**: 支持不同优先级和过期策略

通过合理使用这些功能，可以显著提升应用性能和用户体验。 