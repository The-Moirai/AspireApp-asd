# 服务层迁移指南

## 📋 概述

本文档描述了从原有服务架构迁移到新的分层架构的详细步骤和注意事项。

## 🏗️ 新架构结构

### 原有架构
```
Controllers
├── DronesController (直接使用 DroneDataService)
├── HistoryDataController (直接使用 DroneDataService + TaskDataService)
└── SystemController (直接使用 DroneDataService + TaskDataService)
```

### 新架构
```
Controllers (控制器层)
├── NewDronesController (使用 DroneService)
└── NewTasksController (使用 TaskService)

Services (业务服务层)
├── Clean/
│   ├── DroneService (业务逻辑 + 缓存)
│   └── TaskService (业务逻辑 + 缓存)

Data (数据访问层)
├── DroneRepository (实现 IDroneRepository)
└── TaskRepository (实现 ITaskRepository)

Interfaces (接口层)
├── IDroneRepository
└── ITaskRepository
```

## 🔄 迁移步骤

### 1. 依赖注入配置已更新

在 `Program.cs` 中已添加新的服务注册：

```csharp
// 数据访问层
builder.Services.AddScoped<IDroneRepository, DroneRepository>();
builder.Services.AddScoped<ITaskRepository, TaskRepository>();

// 业务服务层
builder.Services.AddScoped<DroneService>();
builder.Services.AddScoped<TaskService>();

// 原有服务（保持兼容性）
builder.Services.AddSingleton<DroneDataService>();
builder.Services.AddSingleton<TaskDataService>();
```

### 2. 新控制器已创建

- `NewDronesController` - 使用新的 `DroneService`
- `NewTasksController` - 使用新的 `TaskService`

### 3. 配置已更新

在 `appsettings.json` 中添加了 `DataService` 配置：

```json
{
  "DataService": {
    "MaxRetryAttempts": 3,
    "CacheExpirationMinutes": 10,
    "MaxConcurrentOperations": 10,
    "EnableRealTimeUpdates": true,
    "BatchSize": 50,
    "EnablePerformanceMonitoring": true,
    "DatabaseTimeoutSeconds": 30,
    "EnableConnectionPooling": true,
    "MaxPoolSize": 100,
    "MinPoolSize": 5
  }
}
```

## 🚀 使用新API

### 无人机API

**原有API:**
```
GET /api/drones
GET /api/drones/{id}
POST /api/drones
PUT /api/drones/{id}
DELETE /api/drones/{id}
```

**新API:**
```
GET /api/newdrones
GET /api/newdrones/{id}
GET /api/newdrones/name/{droneName}
POST /api/newdrones
PUT /api/newdrones/{id}
DELETE /api/newdrones/{id}
GET /api/newdrones/cluster/status
GET /api/newdrones/{id}/data
GET /api/newdrones/data/all
PUT /api/newdrones/bulk
GET /api/newdrones/statistics
```

### 任务API

**原有API:**
```
GET /api/historydata/tasks/all
GET /api/historydata/task/{taskId}
```

**新API:**
```
GET /api/newtasks
GET /api/newtasks/{id}
POST /api/newtasks
PUT /api/newtasks/{id}
DELETE /api/newtasks/{id}
GET /api/newtasks/{id}/subtasks
GET /api/newtasks/{taskId}/subtasks/{subTaskId}
POST /api/newtasks/{taskId}/subtasks
PUT /api/newtasks/{taskId}/subtasks/{subTaskId}
DELETE /api/newtasks/{taskId}/subtasks/{subTaskId}
GET /api/newtasks/{taskId}/subtasks/{subTaskId}/images
GET /api/newtasks/images/{imageId}
POST /api/newtasks/{taskId}/subtasks/{subTaskId}/images
DELETE /api/newtasks/images/{imageId}
GET /api/newtasks/{taskId}/data/{droneId}
PUT /api/newtasks/bulk
GET /api/newtasks/statistics
GET /api/newtasks/status/statistics
```

## 📊 性能对比

### 原有架构
- ❌ 控制器直接访问数据库服务
- ❌ 缺乏统一的数据访问接口
- ❌ 缓存逻辑分散在各个服务中
- ❌ 难以进行单元测试

### 新架构
- ✅ 清晰的分层职责
- ✅ 统一的数据访问接口
- ✅ 集中的缓存管理
- ✅ 易于单元测试
- ✅ 更好的错误处理
- ✅ 性能监控和统计

## 🔧 逐步迁移建议

### 阶段1: 并行运行（当前状态）
- 保持原有API可用
- 新API通过 `/api/newdrones` 和 `/api/newtasks` 访问
- 逐步将前端迁移到新API

### 阶段2: 完全迁移
- 将原有控制器重命名为 `LegacyDronesController`
- 将新控制器重命名为 `DronesController`
- 更新所有前端调用

### 阶段3: 清理
- 移除旧的服务和控制器
- 清理不再使用的代码

## 🧪 测试建议

### 单元测试
```csharp
// 测试数据访问层
[Test]
public async Task DroneRepository_GetByIdAsync_ShouldReturnDrone()
{
    // Arrange
    var mockSqlserverService = new Mock<SqlserverService>();
    var repository = new DroneRepository(mockSqlserverService.Object, logger);
    
    // Act
    var result = await repository.GetByIdAsync(droneId);
    
    // Assert
    Assert.IsNotNull(result);
}
```

### 集成测试
```csharp
// 测试业务服务层
[Test]
public async Task DroneService_GetDronesAsync_ShouldReturnCachedData()
{
    // Arrange
    var mockRepository = new Mock<IDroneRepository>();
    var service = new DroneService(mockRepository.Object, logger, cache, options);
    
    // Act
    var result1 = await service.GetDronesAsync();
    var result2 = await service.GetDronesAsync();
    
    // Assert
    Assert.AreEqual(result1, result2); // 第二次应该从缓存返回
}
```

## ⚠️ 注意事项

1. **数据一致性**: 新架构使用Scoped生命周期，确保数据一致性
2. **缓存策略**: 新架构有更完善的缓存失效策略
3. **错误处理**: 新架构提供更详细的错误信息和日志
4. **性能监控**: 新架构内置性能统计和监控功能

## 📈 监控指标

新架构提供以下监控指标：

- 总操作次数
- 缓存命中率
- 平均响应时间
- 数据库连接状态
- 内存使用情况
- 活跃连接数

## 🆘 故障排除

### 常见问题

1. **依赖注入错误**
   - 检查 `Program.cs` 中的服务注册
   - 确保所有必要的服务都已注册

2. **缓存问题**
   - 检查缓存配置
   - 验证缓存键的一致性

3. **数据库连接问题**
   - 检查连接字符串配置
   - 验证数据库服务是否正常运行

### 日志查看

新架构提供详细的日志记录，可以通过以下方式查看：

```csharp
// 在控制器中
_logger.LogInformation("操作成功: {Operation}", operationName);
_logger.LogError(ex, "操作失败: {Operation}", operationName);
```

## 📞 支持

如有问题，请查看：
1. 应用程序日志
2. 性能监控指标
3. 数据库连接状态
4. 缓存统计信息 